From 02d27c02481b8eba6f9693158d5ba3fbf9b2d1d6 Mon Sep 17 00:00:00 2001
From: Guo Deshui <deshui.guo@intel.com>
Date: Tue, 26 May 2015 13:02:40 +0800
Subject: [patch] gstreamer-vaapi-support-dmabuf-import

introduce 2 commits for dmabuf import

commit e582b728260a0a1d20b49c5bb26c6e95596a1c4b
Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date:   Mon Mar 2 13:28:41 2015 +0100

    plugins: fix detection of upstream v4l2src element.

    Improve check for upstream element that requires DMABUF buffer pool,
    e.g. v4l2src element. In particular, make sure to traverse through
    any additional capsfilter for instance.

    Note: the traversal to the top-most upstream element could be made
    more generic, but we are insofar only interested in supporting pipes
    similar to v4l2src or v4l2src ! capsfilter, e.g. with an explicit
    specification for a desired video camera format, or resolution.

commit 217ae51fb3142ce6a4d8c5514e4085b122ca10fd
Author: Gwenole Beauchesne <gwenole.beauchesne@intel.com>
Date:   Mon Mar 2 11:12:53 2015 +0100

    plugins: fix allocation of DMABUF memory.

    The dmabuf allocator would close the DMABUF handle passed in the init
    function gst_dmabuf_allocator_alloc(). So, we need to dup() it so that
    to avoid a double close, ultimately in the underlying driver that owns
    the DMABUF handle.
---
 gst/vaapi/gstvaapipluginbase.c  |   37 ++++++++++++++++++++++++++++---------
 gst/vaapi/gstvaapivideomemory.c |   15 +++++++++++++--
 2 files changed, 41 insertions(+), 11 deletions(-)

diff --git a/gst/vaapi/gstvaapipluginbase.c b/gst/vaapi/gstvaapipluginbase.c
index ca681aa..aa8093f 100644
--- a/gst/vaapi/gstvaapipluginbase.c
+++ b/gst/vaapi/gstvaapipluginbase.c
@@ -405,27 +405,46 @@ has_dmabuf_capable_peer (GstVaapiPluginBase * plugin, GstPad * pad)
   gboolean is_dmabuf_capable = FALSE;
   gint v;
 
-  do {
+  gst_object_ref (pad);
+
+  for (;;) {
     other_pad = gst_pad_get_peer (pad);
+    gst_object_unref (pad);
     if (!other_pad)
       break;
 
     element = gst_pad_get_parent_element (other_pad);
-    if (!element || !GST_IS_PUSH_SRC (element))
+    gst_object_unref (other_pad);
+    if (!element)
       break;
 
-    element_name = gst_element_get_name (element);
-    if (!element_name || sscanf (element_name, "v4l2src%d", &v) != 1)
+    if (GST_IS_PUSH_SRC (element)) {
+      element_name = gst_element_get_name (element);
+      if (!element_name || sscanf (element_name, "v4l2src%d", &v) != 1)
+        break;
+
+      v = 0;
+      g_object_get (element, "io-mode", &v, NULL);
+      is_dmabuf_capable = v == 5; /* "dmabuf-import" enum value */
+      break;
+    } else if (GST_IS_BASE_TRANSFORM (element)) {
+      element_name = gst_element_get_name (element);
+      if (!element_name || sscanf (element_name, "capsfilter%d", &v) != 1)
+        break;
+
+      pad = gst_element_get_static_pad (element, "sink");
+      if (!pad)
+        break;
+    } else
       break;
 
-    v = 0;
-    g_object_get (element, "io-mode", &v, NULL);
-    is_dmabuf_capable = v == 5; /* "dmabuf-import" enum value */
-  } while (0);
+    g_free (element_name);
+    element_name = NULL;
+    g_clear_object (&element);
+  }
 
   g_free (element_name);
   g_clear_object (&element);
-  g_clear_object (&other_pad);
   return is_dmabuf_capable;
 }
 
diff --git a/gst/vaapi/gstvaapivideomemory.c b/gst/vaapi/gstvaapivideomemory.c
index 04b49f2..cac2163 100644
--- a/gst/vaapi/gstvaapivideomemory.c
+++ b/gst/vaapi/gstvaapivideomemory.c
@@ -21,6 +21,7 @@
  */
 
 #include "gst/vaapi/sysdeps.h"
+#include <unistd.h>
 #include <gst/vaapi/gstvaapisurface_drm.h>
 #include <gst/vaapi/gstvaapisurfacepool.h>
 #include <gst/vaapi/gstvaapiimagepool.h>
@@ -773,6 +774,7 @@ gst_vaapi_dmabuf_memory_new (GstAllocator * allocator, GstVaapiVideoMeta * meta)
   GstVaapiSurface *surface;
   GstVaapiSurfaceProxy *proxy;
   GstVaapiBufferProxy *dmabuf_proxy;
+  gint dmabuf_fd;
   const GstVideoInfo *vip;
   guint flags;
 
@@ -803,8 +805,11 @@ gst_vaapi_dmabuf_memory_new (GstAllocator * allocator, GstVaapiVideoMeta * meta)
   gst_vaapi_video_meta_set_surface_proxy (meta, proxy);
   gst_vaapi_surface_proxy_unref (proxy);
 
-  mem = gst_dmabuf_allocator_alloc (allocator,
-      gst_vaapi_buffer_proxy_get_handle (dmabuf_proxy),
+  dmabuf_fd = gst_vaapi_buffer_proxy_get_handle (dmabuf_proxy);
+  if (dmabuf_fd < 0 || (dmabuf_fd = dup (dmabuf_fd)) < 0)
+    goto error_create_dmabuf_handle;
+
+  mem = gst_dmabuf_allocator_alloc (allocator, dmabuf_fd,
       gst_vaapi_buffer_proxy_get_size (dmabuf_proxy));
   if (!mem)
     goto error_create_dmabuf_memory;
@@ -834,6 +839,12 @@ error_create_dmabuf_proxy:
     gst_vaapi_surface_proxy_unref (proxy);
     return NULL;
   }
+error_create_dmabuf_handle:
+  {
+    GST_ERROR ("failed to duplicate DMABUF handle");
+    gst_vaapi_buffer_proxy_unref (dmabuf_proxy);
+    return NULL;
+  }
 error_create_dmabuf_memory:
   {
     GST_ERROR ("failed to create DMABUF memory");
-- 
1.7.4.4

